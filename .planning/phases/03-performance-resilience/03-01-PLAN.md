---
phase: 03-performance-resilience
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - classes/BlueSky_Circuit_Breaker.php
  - classes/BlueSky_Rate_Limiter.php
  - tests/test-circuit-breaker.php
  - tests/test-rate-limiter.php
autonomous: true

must_haves:
  truths:
    - "After 3 consecutive API failures for an account, requests to that account are blocked"
    - "After 15-minute cooldown expires, one test request is allowed through"
    - "Successful test request after cooldown restores full request flow"
    - "HTTP 429 responses cause the account to wait before retrying"
    - "When no server-specified wait time is given, wait times increase exponentially (60s/120s/300s)"
    - "Rate limit state is per-account (one account rate-limited does not block others)"
  artifacts:
    - path: "classes/BlueSky_Circuit_Breaker.php"
      provides: "Per-account circuit breaker with closed/open/half-open states"
      contains: "class BlueSky_Circuit_Breaker"
    - path: "classes/BlueSky_Rate_Limiter.php"
      provides: "Rate limit detection and exponential backoff"
      contains: "class BlueSky_Rate_Limiter"
    - path: "tests/test-circuit-breaker.php"
      provides: "Unit tests for circuit breaker state machine"
    - path: "tests/test-rate-limiter.php"
      provides: "Unit tests for rate limit detection and backoff"
  key_links:
    - from: "classes/BlueSky_Circuit_Breaker.php"
      to: "WordPress Transient API"
      via: "get_transient/set_transient for state persistence"
      pattern: "get_transient.*bluesky_circuit"
    - from: "classes/BlueSky_Rate_Limiter.php"
      to: "WordPress Transient API"
      via: "get_transient/set_transient for rate limit state"
      pattern: "get_transient.*bluesky_rate_limit"
---

<objective>
Create the circuit breaker and rate limiter classes using TDD. These are the foundational resilience primitives that all API calls will flow through.

Purpose: The circuit breaker prevents cascading failures by stopping requests after 3 consecutive failures per account (15-min cooldown with half-open recovery). The rate limiter detects HTTP 429 responses, respects Retry-After headers, and applies exponential backoff (60s, 120s, 300s with jitter) when headers are absent.

Output: Two fully tested classes ready for integration into the API handler.
</objective>

<execution_context>
@/Users/CRG/.claude/get-shit-done/workflows/execute-plan.md
@/Users/CRG/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-performance-resilience/03-RESEARCH.md
@tests/bootstrap.php
@tests/test-helpers.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement BlueSky_Circuit_Breaker with TDD</name>
  <files>classes/BlueSky_Circuit_Breaker.php, tests/test-circuit-breaker.php</files>
  <action>
RED: Write tests first in tests/test-circuit-breaker.php covering:
- is_available() returns true when circuit is closed (initial state)
- record_failure() increments failure count in transient
- After 3 record_failure() calls, is_available() returns false (circuit open)
- is_available() returns false during 15-minute cooldown period
- After cooldown expires, is_available() returns true and state transitions to half-open
- record_success() in half-open state closes the circuit (resets failures)
- record_failure() in half-open state reopens the circuit
- record_success() in closed state resets failure count
- Different account_ids have independent circuit states

Use Brain Monkey for WordPress function mocking (get_transient, set_transient, delete_transient).
Store state in transients: `bluesky_circuit_{account_id}` for state, `bluesky_failures_{account_id}` for failure count.

GREEN: Implement classes/BlueSky_Circuit_Breaker.php:
- Constructor takes $account_id
- Private constants: FAILURE_THRESHOLD = 3, COOLDOWN_SECONDS = 900 (15 min)
- is_available(): check state transient, handle closed/open/half-open transitions
- record_success(): reset failures on closed state, close circuit on half-open
- record_failure(): increment failures, open circuit at threshold
- Private helpers: get_state(), set_state(), get_state_key(), get_failure_key()
- State stored as array: ['status' => 'closed|open|half_open', 'open_until' => timestamp]

REFACTOR: Clean up if needed, ensure all tests pass.

Run tests: `/Users/CRG/Library/Application Support/Local/lightning-services/php-8.3.8+0/bin/darwin/bin/php tests/phpunit.phar --configuration tests/phpunit.xml --filter CircuitBreaker`
  </action>
  <verify>All circuit breaker tests pass with zero failures. Run the PHPUnit command above.</verify>
  <done>BlueSky_Circuit_Breaker class exists with full state machine (closed/open/half-open), per-account isolation via transients, and all unit tests passing.</done>
</task>

<task type="auto">
  <name>Task 2: Implement BlueSky_Rate_Limiter with TDD</name>
  <files>classes/BlueSky_Rate_Limiter.php, tests/test-rate-limiter.php</files>
  <action>
RED: Write tests first in tests/test-rate-limiter.php covering:
- check_rate_limit() returns false for non-429 responses
- check_rate_limit() returns true for 429 response
- check_rate_limit() extracts Retry-After header (numeric seconds)
- check_rate_limit() parses Retry-After header (HTTP date format)
- check_rate_limit() falls back to exponential backoff when no Retry-After header
- is_rate_limited() returns true when account has active rate limit transient
- is_rate_limited() returns false when rate limit has expired
- get_retry_after() returns remaining seconds until rate limit expires
- calculate_backoff() returns ~60s for attempt 1, ~120s for attempt 2, ~300s for attempt 3+
- Backoff includes jitter (result varies within Â±20% of base delay)
- Different account_ids have independent rate limit states

Mock wp_remote_retrieve_response_code(), wp_remote_retrieve_header(), is_wp_error() with Brain Monkey.

GREEN: Implement classes/BlueSky_Rate_Limiter.php:
- check_rate_limit($response, $account_id): detect 429, extract headers, store state
- is_rate_limited($account_id): check if currently rate-limited
- get_retry_after($account_id): seconds until rate limit expires
- calculate_backoff($attempt): exponential with jitter (private method, test via check_rate_limit)
- parse_retry_after($retry_after): handle numeric seconds and HTTP date formats (private)
- Rate limit state stored in transient `bluesky_rate_limit_{account_id}` as Unix timestamp
- Retry attempt counter in transient `bluesky_rate_attempts_{account_id}`

REFACTOR: Clean up, ensure all tests pass.

Run tests: `/Users/CRG/Library/Application Support/Local/lightning-services/php-8.3.8+0/bin/darwin/bin/php tests/phpunit.phar --configuration tests/phpunit.xml --filter RateLimiter`
  </action>
  <verify>All rate limiter tests pass with zero failures. Run the PHPUnit command above.</verify>
  <done>BlueSky_Rate_Limiter class exists with HTTP 429 detection, Retry-After header parsing, exponential backoff (60/120/300s with jitter), per-account transient storage, and all unit tests passing.</done>
</task>

</tasks>

<verification>
Run full test suite to confirm no regressions:
```bash
"/Users/CRG/Library/Application Support/Local/lightning-services/php-8.3.8+0/bin/darwin/bin/php" tests/phpunit.phar --configuration tests/phpunit.xml
```
All existing tests plus new circuit breaker and rate limiter tests pass.
</verification>

<success_criteria>
- BlueSky_Circuit_Breaker.php implements full state machine with per-account isolation
- BlueSky_Rate_Limiter.php detects 429s, parses Retry-After, applies exponential backoff
- Both classes store state in WordPress transients (persistent across requests)
- All unit tests pass with Brain Monkey mocking
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/03-performance-resilience/03-01-SUMMARY.md`
</output>
