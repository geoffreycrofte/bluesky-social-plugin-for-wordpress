---
phase: 03-performance-resilience
plan: 05
type: execute
wave: 3
depends_on: ["03-01", "03-02", "03-03", "03-04"]
files_modified:
  - classes/BlueSky_API_Handler.php
  - classes/BlueSky_Render_Front.php
  - classes/BlueSky_AJAX_Service.php
  - classes/BlueSky_Helpers.php
  - templates/frontend/stale-indicator.php
autonomous: true

must_haves:
  truths:
    - "API handler checks rate limiter before making requests"
    - "API handler records successes/failures with circuit breaker after each request"
    - "API handler uses request cache for deduplication within same page render"
    - "Frontend rendering serves stale cached data with 'last updated X ago' indicator when cache is expired"
    - "Stale cache triggers background refresh via Action Scheduler"
    - "AJAX endpoints use request cache for deduplication"
    - "Rate-limited frontend requests serve cached data instead of empty/error state"
  artifacts:
    - path: "classes/BlueSky_API_Handler.php"
      provides: "Integrated rate limiter, circuit breaker, and request cache into all API calls"
    - path: "classes/BlueSky_Render_Front.php"
      provides: "Stale-while-revalidate rendering with 'last updated' indicator"
    - path: "templates/frontend/stale-indicator.php"
      provides: "HTML template for 'last updated X ago' indicator"
  key_links:
    - from: "classes/BlueSky_API_Handler.php"
      to: "classes/BlueSky_Circuit_Breaker.php"
      via: "record_success/record_failure after each API call"
      pattern: "record_success|record_failure"
    - from: "classes/BlueSky_API_Handler.php"
      to: "classes/BlueSky_Rate_Limiter.php"
      via: "check_rate_limit on every response, is_rate_limited before requests"
      pattern: "check_rate_limit|is_rate_limited"
    - from: "classes/BlueSky_API_Handler.php"
      to: "classes/BlueSky_Request_Cache.php"
      via: "Static cache check before transient/API calls"
      pattern: "BlueSky_Request_Cache::has|::get|::set"
    - from: "classes/BlueSky_Render_Front.php"
      to: "classes/BlueSky_API_Handler.php"
      via: "fetch methods with stale-while-revalidate support"
      pattern: "fetch_bluesky_posts|fetch_bluesky_profile"
---

<objective>
Wire the circuit breaker, rate limiter, and request cache into the existing API handler and rendering pipeline. Implement stale-while-revalidate caching for frontend display.

Purpose: This plan connects all the resilience primitives (Plans 01-04) into the actual request flow. After this plan, every API call is protected by rate limiting and circuit breaking, every page render benefits from request deduplication, and frontend displays gracefully degrade with stale cached data.

Output: Fully integrated resilience layer across API handler, renderer, and AJAX service.
</objective>

<execution_context>
@/Users/CRG/.claude/get-shit-done/workflows/execute-plan.md
@/Users/CRG/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-performance-resilience/03-RESEARCH.md
@.planning/phases/03-performance-resilience/03-01-SUMMARY.md
@.planning/phases/03-performance-resilience/03-02-SUMMARY.md
@.planning/phases/03-performance-resilience/03-03-SUMMARY.md
@classes/BlueSky_API_Handler.php
@classes/BlueSky_Render_Front.php
@classes/BlueSky_AJAX_Service.php
@classes/BlueSky_Helpers.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate resilience layer into BlueSky_API_Handler</name>
  <files>classes/BlueSky_API_Handler.php</files>
  <action>
Modify BlueSky_API_Handler.php to integrate circuit breaker, rate limiter, and request cache into the API call pipeline.

**Add class properties:**
- private $circuit_breaker (BlueSky_Circuit_Breaker instance, created lazily when account_id is set)
- private $rate_limiter (BlueSky_Rate_Limiter instance, created in constructor)

**Modify fetch_bluesky_posts():**

1. REQUEST CACHE CHECK (first): Build key via BlueSky_Request_Cache::build_key('posts', ['account_id' => $this->account_id, 'limit' => $limit, ...]). If BlueSky_Request_Cache::has($key), return cached value immediately. Zero API calls, zero transient lookups.

2. TRANSIENT CACHE CHECK (second): Existing transient cache check. If cache hit, also store in request cache and return.

3. CIRCUIT BREAKER CHECK (before API call): If account_id is set, create BlueSky_Circuit_Breaker($this->account_id) and check is_available(). If circuit is open, return cached data (stale) or false.

4. RATE LIMITER CHECK (before API call): Check $this->rate_limiter->is_rate_limited($this->account_id ?? 'default'). If rate limited, return cached data (stale) or false.

5. MAKE API CALL: Existing wp_remote_get logic.

6. RATE LIMITER ON RESPONSE: Call $this->rate_limiter->check_rate_limit($response, $account_id). If rate limited (429), return cached data (stale) or false.

7. CIRCUIT BREAKER ON RESPONSE: On success → $this->circuit_breaker->record_success(). On failure → $this->circuit_breaker->record_failure().

8. STORE IN CACHES: Store result in both transient cache (with extended TTL for stale fallback: cache_duration * 2) AND request cache. Also set a freshness marker transient ({cache_key}_fresh) with normal cache_duration TTL.

**Apply same pattern to fetch_bluesky_profile():** Request cache → transient → circuit breaker → rate limiter → API call → record result → cache in both layers.

**Modify syndicate_post_to_bluesky():** Only add circuit breaker + rate limiter checks (no caching for write operations). On 429 response, check rate limiter. Record success/failure on circuit breaker.

**Stale cache helper (private method):**
- get_stale_cache($cache_key): Try get_transient($cache_key) — since we store with 2x TTL, data may exist even after freshness expires
- Returns data or false

**IMPORTANT:** Do NOT change method signatures. The resilience layer is internal — callers don't know about it. Return types and parameters stay the same.
  </action>
  <verify>PHP syntax check. Read the file and verify: request cache check at top of fetch methods, circuit breaker and rate limiter checks before API calls, result recording after API calls, stale cache fallback.</verify>
  <done>Every API call in BlueSky_API_Handler flows through: request cache → transient cache → circuit breaker → rate limiter → API → record result → cache result. Method signatures unchanged.</done>
</task>

<task type="auto">
  <name>Task 2: Implement stale-while-revalidate in Render_Front and AJAX</name>
  <files>classes/BlueSky_Render_Front.php, classes/BlueSky_AJAX_Service.php, classes/BlueSky_Helpers.php, templates/frontend/stale-indicator.php</files>
  <action>
**Modify BlueSky_Render_Front.php — stale-while-revalidate rendering:**

In render_bluesky_posts_list() and render methods that fetch data:
1. Call API handler's fetch method (which now has request cache + transient cache + resilience built in)
2. After getting data, check if data is stale: check if the freshness transient ({cache_key}_fresh) exists
   - Add a helper method or use BlueSky_Helpers to check freshness
3. If data is stale (freshness expired but data exists):
   - Schedule background refresh via Action Scheduler if available: as_schedule_single_action(time(), 'bluesky_refresh_cache', [...], 'bluesky-cache-refresh') — but only if not already scheduled (check {cache_key}_refreshing transient)
   - Set {cache_key}_refreshing transient to prevent duplicate refresh jobs (TTL: 300 seconds)
   - Include "last updated X ago" indicator in rendered output
4. If data is fresh: render normally without indicator

**Create templates/frontend/stale-indicator.php:**
```php
<div class="bluesky-stale-indicator" style="font-size: 0.8em; color: #666; margin-top: 5px;">
    <?php printf(
        esc_html__('Last updated %s ago', 'social-integration-for-bluesky'),
        esc_html($time_ago)
    ); ?>
</div>
```

**Add to BlueSky_Helpers.php:**
- public static function time_ago($timestamp): Convert Unix timestamp to human-readable "X minutes ago", "X hours ago" format. Use human_time_diff() WordPress function.
- public static function is_cache_fresh($cache_key): Check if {cache_key}_fresh transient exists. Returns boolean.
- public static function schedule_cache_refresh($cache_key, $account_id, $params): Schedule Action Scheduler job if not already scheduled. Sets refreshing lock transient.

**Register background refresh hook:**
Add action hook for 'bluesky_refresh_cache' — this can go in BlueSky_API_Handler or a new static init method. The callback should:
1. Create API handler for the account
2. Fetch fresh data (bypassing cache)
3. Update transient with fresh data (2x TTL for stale fallback)
4. Set freshness marker transient (normal TTL)
5. Clear refreshing lock

**Modify BlueSky_AJAX_Service.php:**
- In ajax_fetch_bluesky_posts(): The API handler already has request cache integrated. No changes needed if the AJAX handler just calls fetch_bluesky_posts(). But verify it doesn't bypass the cache somehow.

**Key per user decision:** When rate-limited on frontend, serve stale cached data with indicator — NEVER show empty/error state if cache exists. The API handler already returns stale data when rate limited (Task 1 ensures this). The renderer just needs to detect staleness and add the indicator.
  </action>
  <verify>PHP syntax check on all modified files. Verify templates/frontend/ directory exists. Verify stale-indicator template uses proper escaping and text domain.</verify>
  <done>Frontend renders serve stale cached data with "last updated X ago" indicator when cache is expired, background refresh is scheduled via Action Scheduler, and AJAX endpoints benefit from request-level deduplication.</done>
</task>

</tasks>

<verification>
1. PHP syntax check on all modified files
2. Run full test suite (some tests may need updates for new dependencies):
```bash
"/Users/CRG/Library/Application Support/Local/lightning-services/php-8.3.8+0/bin/darwin/bin/php" tests/phpunit.phar --configuration tests/phpunit.xml
```
3. Read API handler and verify 3-layer cache check order: request cache → transient → API
4. Read Render_Front and verify stale detection + indicator rendering
5. Verify stale-indicator template exists and uses proper escaping
</verification>

<success_criteria>
- API handler has 3-layer cache: request (static) → transient (database) → API (network)
- Circuit breaker checked before every API call (when account_id set)
- Rate limiter checked before every API call
- Rate limiter checks response for 429 after every API call
- Stale cache served when circuit is open or rate limited
- Frontend shows "last updated X ago" for stale data
- Background refresh scheduled for stale cache (Action Scheduler)
- No duplicate refresh jobs (refreshing lock transient)
- Method signatures unchanged (backward compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/03-performance-resilience/03-05-SUMMARY.md`
</output>
